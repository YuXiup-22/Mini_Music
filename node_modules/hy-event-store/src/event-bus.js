// 注意，这里的on和emit其实不能发送事件，主要是为了方便数据监听

class HYEventBus {
  constructor() {
    this.eventBus = {}
  }
// 接收，设置监听数据和其回调函数--同时也可以接收事件，先设置事件的名字，把回调函数添加进去后，emit在发送事件名时，就会启动回调函数，其实回调函数不是在on里面执行的，其实在emit中执行的，但是回调函数写在on中，所以理所当然在on中就拿得到值（或者可以操作结果）
  on(eventName, eventCallback, thisArg) {
    if (typeof eventName !== "string") {
      throw new TypeError("the event name must be string type")
    }

    if (typeof eventCallback !== "function") {
      throw new TypeError("the event callback must be function type")
    }
    // 找到要进行的操作
    let hanlders = this.eventBus[eventName]
    // 不存在该操作，那么此刻在eventBus中添加要监听的内容
    if (!hanlders) {
      hanlders = []
      this.eventBus[eventName] = hanlders
    }
// 然后把变量和对应的回调函数添加进去，使得其绑定到一起
    hanlders.push({
      eventCallback,
      thisArg
    })
    return this
  }

  once(eventName, eventCallback, thisArg) {
    if (typeof eventName !== "string") {
      throw new TypeError("the event name must be string type")
    }

    if (typeof eventCallback !== "function") {
      throw new TypeError("the event callback must be function type")
    }
    
    const tempCallback = (...payload) => {
      this.off(eventName, tempCallback)
      eventCallback.apply(thisArg, payload)
    }

    return this.on(eventName, tempCallback, thisArg)
  }
// 发送事件 ，名字，和参数
  emit(eventName, ...payload) {
    if (typeof eventName !== "string") {
      throw new TypeError("the event name must be string type")
    }
    // 在事件队列中找到被要求相应的方法
    const handlers = this.eventBus[eventName] || []
    handlers.forEach(handler => {
      handler.eventCallback.apply(handler.thisArg, payload)
    })
    return this
  }

  off(eventName, eventCallback) {
    if (typeof eventName !== "string") {
      throw new TypeError("the event name must be string type")
    }

    if (typeof eventCallback !== "function") {
      throw new TypeError("the event callback must be function type")
    }

    const handlers = this.eventBus[eventName]
    if (handlers && eventCallback) {
      const newHandlers = [...handlers]
      for (let i = 0; i < newHandlers.length; i++) {
        const handler = newHandlers[i]
        if (handler.eventCallback === eventCallback) {
          const index = handlers.indexOf(handler)
          handlers.splice(index, 1)
        }
      }
    }

    if (handlers.length === 0) {
      delete this.eventBus[eventName]
    }
  }
}

module.exports = HYEventBus

